/*
HC-SR04 Ping distance sensor

These are the pin connections: 
VCC to Arduino 5V
GND to Arduino GND
Echo to Arduino pin 13
Trig to Arduino pin 12
More info at: http://goo.gl/kJ8Gl
Original code improvements to the Ping sketch sourced from Trollmaker.com
Some code and wiring inspired by http://en.wikiversity.org/wiki/User:Dstaub/robotcar
Modified by Tolson Winters (Aug 27, 2014) for simplified serial monitor reading.
*/

#define trigPin 12  // Trig Pin On Sensor To DIGITAL PIN 12 ON ARDUINO // 
#define echoPin 13  // Echo Pin on Sensor To DIGITAL PIN 13 ON ARDUINO //

void setup() 
{
  Serial.begin (9600);
  pinMode(trigPin, OUTPUT);
  pinMode(echoPin, INPUT);
}

void loop() 
{
  long duration, distance;
  digitalWrite(trigPin, LOW);
  delayMicroseconds(2);
  digitalWrite(trigPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPin, LOW);
  duration = pulseIn(echoPin, HIGH);
  distance = (duration/2) / 29.1;

  if (distance >= 400 || distance <= 0) // Recognizing whether or not sensor is out of range => Not necessary but keep it //
  {
    Serial.println("Out of range"); 
  }

  else  
  {
    Serial.print(distance);     
    Serial.println(" cm");      // Printing out the distance measured by sensor in centimeters //
  }

  delay(0);
}

if (  (distance > 15) || (distance < 6) ) // Recognizing if there is an edge //  

{ 

void turn( double theta_next, double theta_current, double motor_drive_forward ); // If there's an edge => Call turn function to avoid// //

float mapfloat(long x, long in_min, long in_max, long out_min, long out_max);

void setup(void) 
{
  ///// set up gyro and printing
      #ifndef ESP8266
        while (!Serial);     // will pause Zero, Leonardo, etc until serial console opens

      #endif
        Serial.begin(9600);
      //  Serial.println(F("LSM9DS0 9DOF Sensor Test")); Serial.println("");
        
        /* Initialise the sensor */
        if(!lsm.begin())

        {
          /* There was a problem detecting the LSM9DS0 ... check your connections */
          Serial.print(F("Ooops, no LSM9DS0 detected ... Check your wiring or I2C ADDR!"));
          while(1);
        }
      //  Serial.println(F("Found LSM9DS0 9DOF"));
        
        /* Display some basic information on this sensor */
        displaySensorDetails();
        
        /* Setup the sensor gain and integration time */
        configureSensor();
        
        /* We're ready to go! */
       //Serial.println("Begin Calibration");
      
      
      for (i=0; i<100; i++) 
      {
        sensors_event_t accel, mag, gyro, temp;
      
        lsm.getEvent(&accel, &mag, &gyro, &temp); 
      
       
        //biasx = gyro.gyro.x + biasx; 
      
      biasz = gyro.gyro.z + biasz;
      }
      
      biasz = biasz/100.;
      delay(0);

  ///// set up turning algorithm
      pinMode(pot_pin, INPUT);
      theta_current = 0;
      motor_drive_forward = 0; //0-256
  ///// set up motor driving
      AFMS.begin();  // create with the default frequency 1.6KHz
      //AFMS.begin(1000);  // OR with a different frequency, say 1KHz
      // Set the speed to start, from 0 (off) to 255 (max speed)
}

void loop(void) 
{  
  ///// update angle estimate
      /* Get a new sensor event */ 
      sensors_event_t accel, mag, gyro, temp;
    
      lsm.getEvent(&accel, &mag, &gyro, &temp); 
      
      dt = (millis() - prev_time)/(1000.0); 
      anglez = (anglez) + (gyro.gyro.z-biasz)*(dt);
    
      prev_time = millis();
      
      theta_current = (int(anglez) % (360)) *(PI/180);
      Serial.print(" current gyro angle: ");
      Serial.print( theta_current );
      Serial.print("\t\t");
      
  ///// do turning algorithm
      pot_value = analogRead(pot_pin);
      
     // theta_next = mapfloat(pot_value,0,1023,0,2*PI); // min = 0 rad. max = 2 PI rad

      theta_next = theta_current + (PI/2) // Assuming we are on a square table (4 corners, 90 degrees) with no obstacles // 

      
      //if ( millis() - prev_time_turning > dt_turning )
      //{
        turn(theta_next, theta_current, motor_drive_forward);
        delay(10);
      //}
     
     
      Serial.print( theta_next );
      Serial.println(" " );
  delay(0);
}

void turn( double theta_next, double theta_current, double motor_drive_forward )
{
  ///// calculate amount to turn
      double theta_dot, turn_adjust, motor_drive_L, motor_drive_R;
      theta_dot = theta_next - theta_current; //in radians
      
      turn_adjust = fudge_factor * L_wheelbase / 2.0 * theta_dot / (k_motor * r_wheel * (dt_turning/1000)); //in units of duty cycle,between -255 to 255
      motor_drive_L = constrain( motor_drive_forward + turn_adjust, -speedlimit, speedlimit);
      motor_drive_R = constrain( motor_drive_forward - turn_adjust, -speedlimit, speedlimit);
      
      
  ///// send command to motors      
      if (motor_drive_L > 0)
      {
        leftMotor->setSpeed(mapfloat(motor_drive_L,0,maxspeed,minspeed,maxspeed));
        leftMotor->run(FORWARD);
      }
     
      else 
      { 
        leftMotor->setSpeed( - mapfloat(motor_drive_L,0,maxspeed,minspeed,maxspeed));
        leftMotor->run(BACKWARD);     
      }

      if (motor_drive_R < 0)
      {
        rightMotor->setSpeed(mapfloat(motor_drive_R,0,-maxspeed,minspeed,maxspeed));
        rightMotor->run(BACKWARD);
      }
      else 
      { 
        rightMotor->setSpeed(mapfloat(motor_drive_R,0,maxspeed,minspeed,maxspeed));
        rightMotor->run(FORWARD);     
      }
      //delay(10);
      
      //leftMotor->run(RELEASE);  //This is to unhooks the motor from the controller so you won't be able to control the wheels 
      //rightMotor->run(RELEASE);

      Serial.print(" theta_dot: ");
      Serial.print( theta_dot );
      Serial.print("\t\t\t");

      Serial.print(" turn adjust: ");
      Serial.print( turn_adjust );
      Serial.print("\t\t\t");

      Serial.print(" motor drive L: ");
      if (motor_drive_L > 0)
        Serial.print( mapfloat(motor_drive_L,0,maxspeed,minspeed,maxspeed) );
      else
        Serial.print( mapfloat(motor_drive_L,0,-maxspeed,-minspeed,-maxspeed) );
 
      Serial.print("\t\t\t");
      Serial.print(" motor drive R: ");
      if (motor_drive_R > 0)
        Serial.print( mapfloat(motor_drive_R,0,maxspeed,minspeed,maxspeed) );
      else
        Serial.print( mapfloat(motor_drive_R,0,-maxspeed,-minspeed,-maxspeed) );
      Serial.print("\t\t\t");
    prev_time_turning = millis();
}

float mapfloat(long x, long in_min, long in_max, long out_min, long out_max)
{
 return (float)(x - in_min) * (out_max - out_min) / (float)(in_max - in_min) + out_min;
}

}





